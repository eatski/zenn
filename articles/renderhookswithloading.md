---
title: "Render hooks with loading のすすめ" # 記事のタイトル
emoji: "🐺" # アイキャッチとして使われる絵文字（1文字だけ）
type: "tech" # tech: 技術記事 / idea: アイデア記事
topics: ["frontend"] # タグ。["markdown", "rust", "aws"]のように指定する
published: false # 公開設定（falseにすると下書き）
---

- Render hooks with loading という設計パターンを推奨したい

## 当パターンが有効となる前提

- Reactを使っている
  - React以外でも有効なライブラリはありそうだが、Reactくらい柔軟に実装できる必要はある
- データフェッチをSWRなどを使ってクライアントサイドで行なっている 
- ディレクトリ構成として package by feature もしくはそれに近い機能的関心を優先したディレクトリ構成パターンを採用している

## やりたいこと
- 機能的関心にて分割したUIについて、データフェッチ及びそのデータを使うマークアップのコードは1つのコンポーネントにまとめたい
  - 可読性: データフェッチとマークアップの関係性がわかりやすくなる
  - コンポーネントの使用性: カプセル化されており、コンポーネント使用側は内部を知らずにUIを呼び出せる
  - テスタビリティ: データフェッチとマークアップが結合した、よりプロダクションに近い実装状態でテストできる

TODO: コンポーネントの実装例

## 立ちはだかる壁　ローディング

- クライアントでデータフェッチする場合、ローディング時の状態を考慮する必要がある
- 前述の実装例ではコンポーネントがローディングのUI表現に対する責務を持っているが以下の問題がある
  - コンポーネント毎にローディング状態のUI表現を考える必要がある（UIデザイナー視点）
  - 各コンポーネントが個別でデータフェッチをしてると激しいレイアウトシフトが発生する
- このように、関心事によるコンポーネントの分割単位とローディングを表現する分割単位を一致させると問題がある。
  - 最適なローディングの単位はイコールじゃない。大抵ローディングは機能的関心による分割を超えた大きな単位で行いたい
  - レイアウトシフトについて考慮すべきなのはページなどの大きな粒度のコンポーネントであり、子が考えることではない。

## そこで Render hooks with loading

```tsx
const usePostsViewWithLoading = () => {
    const {isLoading,data} = useSWR("/api/posts",fetcher);
    return {
        isLoading,
        view: !isLoading ? <PresentationalPosts posts={data} /> : null
    }
}
```

- どういうもの？
  - https://qiita.com/uhyo/items/cb6983f52ac37e59f37e の1つの形
    - Render hooksとは JSXをhooksが返す設計パターン
  - ローディングの状態をisLoadingとしてbooleanで返し、hooksはローディング時のハンドリングを行わない。
- メリット
  - 使う側にローディングの責務を移譲できる
  - シンプルなJS関数として実装できる

## Suspseneによる対処
- 他の代表的な手段がSuspense（というかこっちが一般的）
- Suspsenseによってコンポーネントのローディングの問題を親に丸投げすることができるようになった

### 問題
- ただ以下の問題がありそう
  - Suspenseを使ったローディング時promiseをthrowするタイプのデータフェッチは、ウォーターフォール問題を起こす
  - https://github.com/facebook/react/issues/31819
- 正直まだまだプロダクションで使うの厳しい

