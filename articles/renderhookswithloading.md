---
title: "Render hooks with loading のすすめ" # 記事のタイトル
emoji: "🐺" # アイキャッチとして使われる絵文字（1文字だけ）
type: "tech" # tech: 技術記事 / idea: アイデア記事
topics: ["frontend"] # タグ。["markdown", "rust", "aws"]のように指定する
published: false # 公開設定（falseにすると下書き）
---

1. Render hooks with loading という設計パターンを推奨したい

## 当パターンが有効となる前提

1. Reactを使っている
  1-1. React以外でも有効なライブラリはありそうだが、Reactくらい柔軟に実装できる必要はある
2. データフェッチをSWRなどを使ってクライアントサイドで行なっている 
3. ディレクトリ構成として package by feature もしくはそれに近い機能的関心を優先したディレクトリ構成パターンを採用している

## やりたいこと
1. 機能的関心にて分割したUIについて、データフェッチ及びそのデータを使うマークアップのコードは1つのコンポーネントにまとめたい
  1-1. 可読性: データフェッチとマークアップの関係性がわかりやすくなる
  1-2. コンポーネントの使用性: カプセル化されており、コンポーネント使用側は内部を知らずにUIを呼び出せる
  1-3. テスタビリティ: データフェッチとマークアップが結合した、よりプロダクションに近い実装状態でテストできる
2. 愚直に実装するとこうなりそう
TODO: コンポーネントの実装例 

## ローディングの問題

1. クライアントサイドでデータフェッチする場合、ローディング時の状態を考慮する必要がある
2. 前述の実装例ではコンポーネントがローディングのUI表現に対する責務を持っているが以下の問題がある
  2-1. コンポーネント毎にローディング状態のUI表現を考える必要がある（UIデザイナー視点）
  2-2. 各コンポーネントが個別でデータフェッチをしてると激しいレイアウトシフトが発生する
3. このように、関心事によるコンポーネントの分割単位でローディングを表現しようとすると問題がある。
  3-1. 最適なローディングの単位は機能的関心による分割よる大きい
  3-2. レイアウトシフトについて考慮すべきなのはページなどの大きな粒度のコンポーネントであり、子が考えることではない。

## そこで Render hooks with loading

```tsx
const usePostsViewWithLoading = () => {
    const {isLoading,data} = useSWR("/api/posts",fetcher);
    return {
        isLoading,
        view: !isLoading ? <PresentationalPosts posts={data} /> : null
    }
}
```
1. 命名の由来
  1-1. 筆者が考えた
  1-2. Render hooksとは JSXをhooksが返す設計パターン 
    1-2-1. https://qiita.com/uhyo/items/cb6983f52ac37e59f37e 
2. どういうもの？
  2-1. ローディングの状態をisLoadingとしてbooleanで返し、hooksはローディング時のハンドリングを行わない。
3. メリット
  3-1. 使う側にローディングの責務を移譲できる
  3-2. シンプルなJS関数として実装できる

## Suspseneではだめ？
1. 他の代表的な手段がSuspense（というかこっちが一般的）
2. Suspsenseによってコンポーネントのローディングのハンドリングを親に丸投げすることができるようになった

### 問題
1. ただ以下の問題がありそう
  1-1. Suspenseを使ったローディング時promiseをthrowするタイプのデータフェッチは、ウォーターフォール問題を起こす
  1-2. https://github.com/facebook/react/issues/31819
2. 正直まだまだプロダクションで使うの厳しい
